// Generated using `moon info`, DON'T EDIT IT
package "bobzhang/zip"

import(
  "bobzhang/zip/bitstream"
  "bobzhang/zip/huffman"
  "bobzhang/zip/types"
  "moonbitlang/core/immut/sorted_map"
)

// Values
fn adler32_and_deflate(Bytes, Int, Int, DeflateLevel?) -> Result[(Int64, Bytes), String]

fn backref_dist(Int) -> Int

fn backref_len(Int) -> Int

fn bytes_adler32(Bytes, Int, Int) -> Int64

fn bytes_crc32(Bytes, Int, Int) -> Int64

fn bytes_has_zip_magic(Bytes) -> Bool

fn check_adler32(Int64, Int64) -> Result[Unit, String]

fn check_crc32(Int64, Int64) -> Result[Unit, String]

fn crc32_and_deflate(Bytes, Int, Int, DeflateLevel?) -> Result[(Int64, Bytes), String]

fn deflate(Bytes, Int, Int, DeflateLevel?) -> Result[Bytes, String]

fn deflate_dynamic(Bytes, Int, Int, Bool, Int, Int) -> Bytes

fn deflate_fixed(Bytes, Int, Int, Bool, Int, Int) -> Bytes

fn deflate_fixed_literals_only(Bytes, Int, Int, Bool) -> Bytes

let dist_value_of_sym : Array[Int]

fn distance_to_symbol(Int) -> Int

let dos_epoch : Int

fn find_backref(Bytes, Array[Int], Array[Int], Int, Int, Int, Int, Int, Int) -> Int

fn find_match_length(Bytes, Int, Int, Int, Int) -> Int

let fixed_dist_decoder : @huffman.HuffmanDecoder

let fixed_dist_encoder : @huffman.HuffmanEncoder

let fixed_litlen_decoder : @huffman.HuffmanDecoder

let fixed_litlen_encoder : @huffman.HuffmanEncoder

fn format_file_mode(Int) -> String

fn fpath_ensure_directoryness(String) -> String

fn fpath_ensure_unix(String) -> String

fn fpath_sanitize(String) -> String

let gp_flag_encrypted : Int

let gp_flag_utf8 : Int

fn hash4(Bytes, Int) -> Int

fn inflate(Bytes, Int, Int, Int?) -> Bytes

fn inflate_and_adler32(Bytes, Int, Int, Int?) -> (Bytes, Int64)

fn inflate_and_crc32(Bytes, Int, Int, Int?) -> (Bytes, Int64)

fn insert_hash(Array[Int], Array[Int], Int, Int) -> Unit

fn length_to_symbol(Int) -> Int

let length_value_of_sym_table : Array[Int]

fn make_backref(Int, Int) -> Int

fn match_fwd(Bytes, Int, Int, Int, Int) -> Int

let max_file_size : Int64

let max_member_count : Int

let max_path_length : Int

fn ptime_format(Int) -> String

fn ptime_of_dos_date_time(Int, Int) -> Int

fn ptime_to_date_time(Int) -> ((Int, Int, Int), (Int, Int, Int))

fn ptime_to_dos_date_time(Int) -> (Int, Int)

fn reverse_bits(Int, Int) -> Int

fn sym_info_code(Int) -> Int

fn sym_info_code_length(Int) -> Int

fn sym_info_make(Int, Int) -> Int

fn write_length_distance(@bitstream.BitWriter, @huffman.HuffmanEncoder, @huffman.HuffmanEncoder, Int, Int) -> Unit

fn write_literal_symbol(@bitstream.BitWriter, @huffman.HuffmanEncoder, Int) -> Unit

fn zlib_compress(Bytes, Int, Int, DeflateLevel?) -> (Int64, Bytes)

fn zlib_decompress(Bytes, Int, Int) -> Result[(Bytes, Int64), String]

// Errors

// Types and methods
pub struct Archive {
  members : @sorted_map.SortedMap[String, Member]
}
fn Archive::add(Self, Member) -> Self
fn Archive::empty() -> Self
fn Archive::encoding_size(Self) -> Int
fn Archive::find(Self, String) -> Member?
fn[T] Archive::fold(Self, (Member, T) -> T, T) -> T
fn Archive::is_empty(Self) -> Bool
fn Archive::mem(Self, String) -> Bool
fn Archive::member_count(Self) -> Int
fn Archive::of_bytes(Bytes) -> Result[Self, String]
fn Archive::of_map(@sorted_map.SortedMap[String, Member]) -> Self
fn Archive::remove(Self, String) -> Self
fn Archive::to_array(Self) -> Array[Member]
fn Archive::to_bytes(Self, String?) -> Result[Bytes, String]
fn Archive::to_map(Self) -> @sorted_map.SortedMap[String, Member]
fn Archive::write_bytes(Self, Bytes, Int, String?) -> Result[Int, String]

pub enum DeflateLevel {
  None
  Fast
  Default
  Best
}
impl Eq for DeflateLevel
impl Show for DeflateLevel

pub struct File {
  version_made_by : Int
  version_needed_to_extract : Int
  gp_flags : Int
  compression : @types.Compression
  start : Int
  compressed_size : Int
  compressed_bytes : Bytes
  decompressed_size : Int
  decompressed_crc32 : Int64
}
fn File::can_extract(Self) -> Bool
fn File::compressed_bytes(Self) -> Bytes
fn File::compressed_bytes_to_bytes(Self) -> Bytes
fn File::compressed_size(Self) -> Int
fn File::compression(Self) -> @types.Compression
fn File::decompressed_crc32(Self) -> Int64
fn File::decompressed_size(Self) -> Int
fn File::deflate_of_bytes(Bytes, Int, Int, DeflateLevel?) -> Result[Self, String]
fn File::gp_flags(Self) -> Int
fn File::is_encrypted(Self) -> Bool
fn File::make(Bytes, Int, Int, @types.Compression, Int, Int64, Int?, Int?, Int?) -> Result[Self, String]
fn File::start(Self) -> Int
fn File::stored_of_bytes(Bytes, Int, Int) -> Result[Self, String]
fn File::to_bytes(Self) -> Bytes
fn File::to_bytes_no_crc_check(Self) -> (Bytes, Int64)
fn File::version_made_by(Self) -> Int
fn File::version_needed_to_extract(Self) -> Int

type FrequencyCounter

pub struct Member {
  path : String
  kind : MemberKind
  mode : Int
  mtime : Int
}
fn Member::format(Self) -> String
fn Member::format_long(Self) -> String
fn Member::is_dir(Self) -> Bool
fn Member::is_file(Self) -> Bool
fn Member::kind(Self) -> MemberKind
fn Member::make(String, MemberKind, Int?, Int?) -> Result[Self, String]
fn Member::mode(Self) -> Int
fn Member::mtime(Self) -> Int
fn Member::path(Self) -> String

pub(all) enum MemberKind {
  Dir
  File(File)
}

// Type aliases
pub typealias @bobzhang/zip/checksum/adler32.Adler32 as Adler32

pub typealias @bitstream.BitWriter as BitWriter

pub typealias @bobzhang/zip/buffer.ByteBuf as ByteBuf

pub typealias @types.Compression as Compression

pub typealias @bobzhang/zip/checksum/crc32.Crc32 as Crc32

pub typealias Int as FileMode

pub typealias String as Fpath

pub typealias @huffman.HuffmanDecoder as HuffmanDecoder

pub typealias @huffman.HuffmanEncoder as HuffmanEncoder

pub typealias Int as Ptime

pub typealias Int as SymInfo

// Traits

