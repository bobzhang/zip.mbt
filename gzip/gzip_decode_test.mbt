// Decoder verification against Python gzip outputs (mtime=0, level=6)
// Generated with: gzip.compress(data, compresslevel=6, mtime=0) in CPython
// Representative (raw, compressed) pairs ensure @gzip.decompress is correct.

///|
test "python_gzip_decode_vectors" {
  let pairs = [
    // empty
    (
      b"", b"\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00",
    ),
    // simple text
    (
      b"hello world", b"\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xcb\x48\xcd\xc9\xc9\x57\x28\xcf\x2f\xca\x49\x01\x00\x85\x11\x4a\x0d\x0b\x00\x00\x00",
    ),
    // single byte
    (
      b"A", b"\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x73\x04\x00\x8b\x9e\xd9\xd3\x01\x00\x00\x00",
    ),
    // mixed binary
    (
      b"\x00\x01\x02\xff\xfe\xfd", b"\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x63\x60\x64\xfa\xff\xef\x2f\x00\xe7\x36\x00\xd1\x06\x00\x00\x00",
    ),
    // whitespace pattern
    (
      b"\n\r\t   ", b"\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xe3\xe2\xe5\x54\x50\x50\x00\x00\x74\x4b\x66\x03\x06\x00\x00\x00",
    ),
    // unicode (Hello 世界)
    (
      b"Hello \xe4\xb8\x96\xe7\x95\x8c", b"\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xf3\x48\xcd\xc9\xc9\x57\x78\xb2\x63\xda\xf3\xa9\x3d\x00\x96\xf3\x1f\xaa\x0c\x00\x00\x00",
    ),
  ]
  for p in pairs {
    let raw = p.0
    let comp = p.1
    let got = @gzip.decompress(comp[:])
    if got != raw {
      fail("gzip decode mismatch")
    }
  }
  // Snapshot marker (content only for stable snapshot)
  inspect("python_gzip_vectors_ok", content="python_gzip_vectors_ok")
}
