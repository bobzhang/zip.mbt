/// Comprehensive round-trip tests comparing MoonBit TAR implementation with Python behavior\n\ntest \"python_comparison_simple_file\" {\n  // Test 1: Create the same TAR structure as Python's test1_simple.tar\n  let archive = @tar.TarArchive::empty()\n  let content = b\"Hello TAR world!\"\n  let entry = {\n    name: \"test.txt\",\n    size: content.length(),\n    data: content,\n    typeflag: @tar.RegularFile,\n    mode: 644, // 0o644\n    uid: 1000,\n    gid: 1000,\n    mtime: 1696694400,\n  }\n  archive.add(entry)\n  \n  // Test our serialization\n  let tar_bytes = archive.to_bytes()\n  @json.inspect(tar_bytes.length(), content=10240) // Same as Python\n  \n  // Test round-trip parsing\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  @json.inspect(parsed.length(), content=1)\n  \n  guard parsed.find(\"test.txt\") is Some(found) else {\n    fail(\"File not found in parsed archive\")\n  }\n  \n  // Verify all fields match Python expectations\n  @json.inspect(found.name, content=\"test.txt\")\n  @json.inspect(found.size, content=16) // \"Hello TAR world!\" = 16 bytes\n  assert_eq(found.data, content)\n  @json.inspect(found.mode, content=644)\n  @json.inspect(found.uid, content=1000)\n  @json.inspect(found.gid, content=1000)\n  @json.inspect(found.mtime, content=1696694400)\n  \n  match found.typeflag {\n    @tar.RegularFile => () // Expected\n    _ => fail(\"Expected RegularFile\")\n  }\n}\n\ntest \"python_comparison_multiple_files\" {\n  // Test 2: Create the same structure as Python's test2_multiple.tar\n  let archive = @tar.TarArchive::empty()\n  \n  // Add readme.txt (first entry in Python output)\n  let readme_content = b\"This is a README\"\n  let readme_entry = {\n    name: \"readme.txt\",\n    size: readme_content.length(),\n    data: readme_content,\n    typeflag: @tar.RegularFile,\n    mode: 644,\n    uid: 1000,\n    gid: 1000,\n    mtime: 1696694400,\n  }\n  archive.add(readme_entry)\n  \n  // Add docs/ directory (second entry)\n  let dir_entry = {\n    name: \"docs/\",\n    size: 0,\n    data: b\"\",\n    typeflag: @tar.Directory,\n    mode: 755, // 0o755\n    uid: 1000,\n    gid: 1000,\n    mtime: 1696694400,\n  }\n  archive.add(dir_entry)\n  \n  // Add docs/guide.md (third entry)\n  let guide_content = b\"# User Guide\\n\\nContent here.\"\n  let guide_entry = {\n    name: \"docs/guide.md\",\n    size: guide_content.length(),\n    data: guide_content,\n    typeflag: @tar.RegularFile,\n    mode: 644,\n    uid: 1000,\n    gid: 1000,\n    mtime: 1696694400,\n  }\n  archive.add(guide_entry)\n  \n  // Test serialization matches Python size\n  let tar_bytes = archive.to_bytes()\n  @json.inspect(tar_bytes.length(), content=10240)\n  \n  // Test round-trip\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  @json.inspect(parsed.length(), content=3)\n  \n  // Verify each entry matches Python output exactly\n  guard parsed.find(\"readme.txt\") is Some(f1) else {\n    fail(\"readme.txt not found\")\n  }\n  assert_eq(f1.data, readme_content)\n  @json.inspect(f1.size, content=16)\n  \n  guard parsed.find(\"docs/\") is Some(d1) else {\n    fail(\"docs/ directory not found\")\n  }\n  @json.inspect(d1.size, content=0)\n  match d1.typeflag {\n    @tar.Directory => ()\n    _ => fail(\"Expected Directory\")\n  }\n  \n  guard parsed.find(\"docs/guide.md\") is Some(f2) else {\n    fail(\"docs/guide.md not found\")\n  }\n  assert_eq(f2.data, guide_content)\n  @json.inspect(f2.size, content=27) // Python reported 27 bytes\n}\n\ntest \"python_comparison_binary_data\" {\n  // Test 3: Binary data exactly like Python's test3_binary.tar\n  let archive = @tar.TarArchive::empty()\n  \n  // Create the exact binary content Python used\n  let binary_content = b\"\\x00\\x01\\x02Hello\\xFF\\xFE World\\x03\\x04\"\n  let entry = {\n    name: \"binary.dat\",\n    size: binary_content.length(),\n    data: binary_content,\n    typeflag: @tar.RegularFile,\n    mode: 644,\n    uid: 1000,\n    gid: 1000,\n    mtime: 1696694400,\n  }\n  archive.add(entry)\n  \n  let tar_bytes = archive.to_bytes()\n  @json.inspect(tar_bytes.length(), content=10240)\n  \n  // Test round-trip with binary data\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  @json.inspect(parsed.length(), content=1)\n  \n  guard parsed.find(\"binary.dat\") is Some(found) else {\n    fail(\"Binary file not found\")\n  }\n  \n  // Verify binary data is preserved exactly\n  assert_eq(found.data, binary_content)\n  @json.inspect(found.size, content=18) // Python reported 18 bytes (not 14 as I initially thought)\n  @json.inspect(found.name, content=\"binary.dat\")\n}\n\ntest \"python_comparison_empty_archive\" {\n  // Test 4: Empty archive like Python's test4_empty.tar\n  let archive = @tar.TarArchive::empty()\n  \n  let tar_bytes = archive.to_bytes()\n  @json.inspect(tar_bytes.length(), content=10240) // Python empty archive size\n  \n  // Test parsing empty archive\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  @json.inspect(parsed.length(), content=0)\n}\n\ntest \"format_compliance_with_python_standards\" {\n  // Verify our implementation follows the same format standards as Python\n  let archive = @tar.TarArchive::empty()\n  \n  // Test file with specific attributes that Python uses\n  let entry = {\n    name: \"compliance_test.txt\",\n    size: 13,\n    data: b\"Format test!\",\n    typeflag: @tar.RegularFile,\n    mode: 644,  // Standard file mode\n    uid: 1000,   // Standard UID\n    gid: 1000,   // Standard GID\n    mtime: 1696694400, // Fixed timestamp for consistency\n  }\n  archive.add(entry)\n  \n  let tar_bytes = archive.to_bytes()\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  \n  guard parsed.find(\"compliance_test.txt\") is Some(found) else {\n    fail(\"Compliance test file not found\")\n  }\n  \n  // Verify all metadata fields are preserved correctly\n  @json.inspect(found.name, content=\"compliance_test.txt\")\n  @json.inspect(found.size, content=13)\n  assert_eq(found.data, b\"Format test!\")\n  @json.inspect(found.mode, content=644)\n  @json.inspect(found.uid, content=1000)\n  @json.inspect(found.gid, content=1000)\n  @json.inspect(found.mtime, content=1696694400)\n  \n  // Verify archive structure matches Python expectations\n  @json.inspect(tar_bytes.length(), content=10240) // Should be minimum size\n  @json.inspect(parsed.length(), content=1)\n}
