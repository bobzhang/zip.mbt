/// Round-trip tests for TAR implementation\n/// Test that we can create TAR → serialize → parse → verify\n\ntest \"tar_roundtrip_simple\" {\n  // Create original archive\n  let original = @tar.TarArchive::empty()\n  let file_data = b\"Hello TAR world!\"\n  let file_entry = @tar.TarEntry::file(\"test.txt\", file_data)\n  original.add(file_entry)\n  \n  // Serialize to bytes\n  let tar_bytes = original.to_bytes()\n  @json.inspect(tar_bytes.length() >= 10240, content=true)\n  \n  // Parse back from bytes\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  @json.inspect(parsed.length(), content=1)\n  \n  // Verify the parsed entry\n  guard parsed.find(\"test.txt\") is Some(found) else {\n    fail(\"File not found in parsed archive\")\n  }\n  @json.inspect(found.name, content=\"test.txt\")\n  @json.inspect(found.size, content=16)\n  assert_eq(found.data, file_data)\n  \n  match found.typeflag {\n    @tar.RegularFile => () // Expected\n    _ => fail(\"Expected RegularFile\")\n  }\n}\n\ntest \"tar_roundtrip_multiple_files\" {\n  let original = @tar.TarArchive::empty()\n  \n  // Add multiple files\n  let file1 = @tar.TarEntry::file(\"readme.txt\", b\"This is a README\")\n  let file2 = @tar.TarEntry::file(\"data.bin\", b\"\\x00\\x01\\x02\\x03\\x04\")\n  let dir1 = @tar.TarEntry::directory(\"docs/\")\n  let file3 = @tar.TarEntry::file(\"docs/guide.md\", b\"# User Guide\\n\\nContent here.\")\n  \n  original.add(file1)\n  original.add(file2)\n  original.add(dir1)\n  original.add(file3)\n  \n  @json.inspect(original.length(), content=4)\n  \n  // Round-trip\n  let tar_bytes = original.to_bytes()\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  \n  @json.inspect(parsed.length(), content=4)\n  \n  // Check each entry\n  guard parsed.find(\"readme.txt\") is Some(f1) else {\n    fail(\"readme.txt not found\")\n  }\n  assert_eq(f1.data, b\"This is a README\")\n  @json.inspect(f1.size, content=16)\n  \n  guard parsed.find(\"data.bin\") is Some(f2) else {\n    fail(\"data.bin not found\")\n  }\n  assert_eq(f2.data, b\"\\x00\\x01\\x02\\x03\\x04\")\n  @json.inspect(f2.size, content=5)\n  \n  guard parsed.find(\"docs/\") is Some(d1) else {\n    fail(\"docs/ directory not found\")\n  }\n  @json.inspect(d1.size, content=0)\n  match d1.typeflag {\n    @tar.Directory => () // Expected\n    _ => fail(\"Expected Directory\")\n  }\n  \n  guard parsed.find(\"docs/guide.md\") is Some(f3) else {\n    fail(\"docs/guide.md not found\")\n  }\n  assert_eq(f3.data, b\"# User Guide\\n\\nContent here.\")\n  @json.inspect(f3.size, content=26)\n}\n\ntest \"tar_roundtrip_empty_archive\" {\n  let original = @tar.TarArchive::empty()\n  \n  let tar_bytes = original.to_bytes()\n  @json.inspect(tar_bytes.length(), content=10240) // Standard empty size\n  \n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  @json.inspect(parsed.length(), content=0)\n}\n\ntest \"tar_roundtrip_large_file\" {\n  let original = @tar.TarArchive::empty()\n  \n  // Create a large file that spans multiple 512-byte blocks\n  let large_data = \"X\".repeat(2000).to_bytes()\n  let large_file = @tar.TarEntry::file(\"large.dat\", large_data)\n  original.add(large_file)\n  \n  let tar_bytes = original.to_bytes()\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  \n  @json.inspect(parsed.length(), content=1)\n  \n  guard parsed.find(\"large.dat\") is Some(found) else {\n    fail(\"Large file not found\")\n  }\n  \n  @json.inspect(found.size, content=2000)\n  assert_eq(found.data, large_data)\n}\n\ntest \"tar_roundtrip_preserve_metadata\" {\n  let original = @tar.TarArchive::empty()\n  \n  // Create entry with specific metadata\n  let file_data = b\"test content\"\n  let entry = {\n    name: \"test.txt\",\n    size: file_data.length(),\n    data: file_data,\n    typeflag: @tar.RegularFile,\n    mode: 0o644,\n    uid: 1000,\n    gid: 1000,\n    mtime: 1696694400,\n  }\n  original.add(entry)\n  \n  let tar_bytes = original.to_bytes()\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  \n  guard parsed.find(\"test.txt\") is Some(found) else {\n    fail(\"File not found\")\n  }\n  \n  // Verify metadata preservation\n  @json.inspect(found.name, content=\"test.txt\")\n  @json.inspect(found.size, content=12)\n  @json.inspect(found.mode, content=420) // 0o644 in decimal\n  @json.inspect(found.uid, content=1000)\n  @json.inspect(found.gid, content=1000)\n  @json.inspect(found.mtime, content=1696694400)\n  assert_eq(found.data, file_data)\n}
