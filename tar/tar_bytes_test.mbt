/// Tests for TAR implementation focusing on raw bytes vs UTF-16 string handling\n/// and header field correctness.\n///|\ntest \"tar_bytes_vs_string_handling\" {\n  // Test that we handle raw bytes correctly in TAR format\n  let archive = @tar.TarArchive::empty()\n  \n  // Create file with non-ASCII / binary bytes to test proper handling\n  let binary_data = b\"\\x00\\x01\\x02Hello\\xFF\\xFE World\\x03\\x04\"\n  // Actual length is 18 bytes (previous test expected 14)\n  let file_entry = @tar.TarEntry::file(\"binary.dat\", binary_data)\n  archive.add(file_entry)\n  \n  // Create file with Unicode content (encoded as UTF-8 in TAR)\n  let unicode_data = \"Hello 世界 🌍\".to_bytes()\n  let unicode_file = @tar.TarEntry::file(\"unicode.txt\", unicode_data)\n  archive.add(unicode_file)\n  \n  // Round-trip\n  let tar_bytes = archive.to_bytes()\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  @json.inspect(parsed.length(), content=2)\n  \n  // Verify binary data preservation\n  guard parsed.find(\"binary.dat\") is Some(found_binary) else { fail(\"Binary file not found\") }\n  assert_eq(found_binary.data, binary_data)\n  @json.inspect(found_binary.size, content=18)\n  \n  // Verify Unicode data preservation\n  guard parsed.find(\"unicode.txt\") is Some(found_unicode) else { fail(\"Unicode file not found\") }\n  assert_eq(found_unicode.data, unicode_data)\n  // UTF-8 encoding of \"Hello 世界 🌍\" should be > 10 bytes\n  @json.inspect(found_unicode.size > 10, content=true)\n}\n\n///|\ntest \"tar_header_field_encoding\" {\n  // Test that TAR header fields are properly encoded as ASCII/UTF-8 bytes\n  let archive = @tar.TarArchive::empty()\n  \n  // ASCII filename\n  let ascii_file = @tar.TarEntry::file(\"test-file_123.txt\", b\"content\")\n  archive.add(ascii_file)\n  \n  // Directory entry (must end with slash)\n  let dir_entry = @tar.TarEntry::directory(\"some-dir/\")\n  archive.add(dir_entry)\n  \n  let tar_bytes = archive.to_bytes()\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  @json.inspect(parsed.length(), content=2)\n  \n  guard parsed.find(\"test-file_123.txt\") is Some(found_file) else { fail(\"ASCII file not found\") }\n  @json.inspect(found_file.name, content=\"test-file_123.txt\")\n  \n  guard parsed.find(\"some-dir/\") is Some(found_dir) else { fail(\"Directory not found\") }\n  @json.inspect(found_dir.name, content=\"some-dir/\")\n  match found_dir.typeflag {\n    @tar.Directory => ()\n    _ => fail(\"Expected Directory type\")\n  }\n}\n\n///|\ntest \"tar_octal_field_parsing\" {\n  // Test that octal (currently treated as decimal) fields round-trip\n  let archive = @tar.TarArchive::empty()\n  \n  let entry = {\n    name: \"test.txt\",\n    size: 5,\n    data: b\"hello\",\n    typeflag: @tar.RegularFile,\n    mode: 644, // Represents 0o644 under current interpretation\n    uid: 1000,\n    gid: 1000,\n    mtime: 1696694400,\n  }\n  archive.add(entry)\n  \n  let tar_bytes = archive.to_bytes()\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  guard parsed.find(\"test.txt\") is Some(found) else { fail(\"File not found\") }\n  \n  @json.inspect(found.mode, content=644)\n  @json.inspect(found.uid, content=1000)\n  @json.inspect(found.gid, content=1000)\n  @json.inspect(found.mtime, content=1696694400)\n  @json.inspect(found.size, content=5)\n  assert_eq(found.data, b\"hello\")\n}\n\n///|\ntest \"tar_format_structure_verification\" {\n  // Verify TAR format follows proper structure & block alignment\n  let archive = @tar.TarArchive::empty()\n  \n  let small_file = @tar.TarEntry::file(\"small.txt\", b\"Hi\")\n  let medium_file = @tar.TarEntry::file(\"medium.txt\", \"x\".repeat(600).to_bytes())\n  let large_file = @tar.TarEntry::file(\"large.txt\", \"y\".repeat(1500).to_bytes())\n  archive.add(small_file)\n  archive.add(medium_file)\n  archive.add(large_file)\n  \n  let tar_bytes = archive.to_bytes()\n  @json.inspect(tar_bytes.length() % 512, content=0)\n  @json.inspect(tar_bytes.length() >= 10240, content=true)\n  \n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  @json.inspect(parsed.length(), content=3)\n  \n  guard parsed.find(\"small.txt\") is Some(f1) else { fail(\"small.txt not found\") }\n  assert_eq(f1.data, b\"Hi\")\n  \n  guard parsed.find(\"medium.txt\") is Some(f2) else { fail(\"medium.txt not found\") }\n  @json.inspect(f2.size, content=600)\n  \n  guard parsed.find(\"large.txt\") is Some(f3) else { fail(\"large.txt not found\") }\n  @json.inspect(f3.size, content=1500)\n}\n
