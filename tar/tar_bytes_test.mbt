/// Test TAR implementation with focus on bytes vs UTF-16 string handling\n\ntest \"tar_bytes_vs_string_handling\" {\n  // Test that we handle raw bytes correctly in TAR format\n  let archive = @tar.TarArchive::empty()\n  \n  // Create file with non-ASCII bytes to test proper handling\n  let binary_data = b\"\\x00\\x01\\x02Hello\\xFF\\xFE World\\x03\\x04\"\n  let file_entry = @tar.TarEntry::file(\"binary.dat\", binary_data)\n  archive.add(file_entry)\n  \n  // Create file with Unicode content (will be encoded as UTF-8 in TAR)\n  let unicode_data = \"Hello 世界 🌍\".to_bytes()\n  let unicode_file = @tar.TarEntry::file(\"unicode.txt\", unicode_data)\n  archive.add(unicode_file)\n  \n  // Test round-trip\n  let tar_bytes = archive.to_bytes()\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  \n  @json.inspect(parsed.length(), content=2)\n  \n  // Verify binary data preservation\n  guard parsed.find(\"binary.dat\") is Some(found_binary) else {\n    fail(\"Binary file not found\")\n  }\n  assert_eq(found_binary.data, binary_data)\n  @json.inspect(found_binary.size, content=14)\n  \n  // Verify Unicode data preservation\n  guard parsed.find(\"unicode.txt\") is Some(found_unicode) else {\n    fail(\"Unicode file not found\")\n  }\n  assert_eq(found_unicode.data, unicode_data)\n  // UTF-8 encoding of \"Hello 世界 🌍\" should be longer than UTF-16\n  @json.inspect(found_unicode.size > 10, content=true)\n}\n\ntest \"tar_header_field_encoding\" {\n  // Test that TAR header fields are properly encoded as ASCII/UTF-8 bytes\n  let archive = @tar.TarArchive::empty()\n  \n  // Test filename with ASCII characters\n  let ascii_file = @tar.TarEntry::file(\"test-file_123.txt\", b\"content\")\n  archive.add(ascii_file)\n  \n  // Test directory name ending with slash\n  let dir_entry = @tar.TarEntry::directory(\"some-dir/\")\n  archive.add(dir_entry)\n  \n  let tar_bytes = archive.to_bytes()\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  \n  @json.inspect(parsed.length(), content=2)\n  \n  // Verify filename preservation\n  guard parsed.find(\"test-file_123.txt\") is Some(found_file) else {\n    fail(\"ASCII file not found\")\n  }\n  @json.inspect(found_file.name, content=\"test-file_123.txt\")\n  \n  // Verify directory name preservation  \n  guard parsed.find(\"some-dir/\") is Some(found_dir) else {\n    fail(\"Directory not found\")\n  }\n  @json.inspect(found_dir.name, content=\"some-dir/\")\n  match found_dir.typeflag {\n    @tar.Directory => () // Expected\n    _ => fail(\"Expected Directory type\")\n  }\n}\n\ntest \"tar_octal_field_parsing\" {\n  // Test that octal fields in TAR headers are parsed correctly\n  let archive = @tar.TarArchive::empty()\n  \n  // Create entry with specific mode, uid, gid values\n  let entry = {\n    name: \"test.txt\",\n    size: 5,\n    data: b\"hello\",\n    typeflag: @tar.RegularFile,\n    mode: 644,  // 0o644 in octal = 420 decimal\n    uid: 1000,\n    gid: 1000,\n    mtime: 1696694400,\n  }\n  archive.add(entry)\n  \n  let tar_bytes = archive.to_bytes()\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  \n  guard parsed.find(\"test.txt\") is Some(found) else {\n    fail(\"File not found\")\n  }\n  \n  // Verify that octal fields are preserved\n  // Note: Current implementation treats octal as decimal for simplicity\n  @json.inspect(found.mode, content=644)\n  @json.inspect(found.uid, content=1000) \n  @json.inspect(found.gid, content=1000)\n  @json.inspect(found.mtime, content=1696694400)\n  @json.inspect(found.size, content=5)\n  assert_eq(found.data, b\"hello\")\n}\n\ntest \"tar_format_structure_verification\" {\n  // Verify TAR format follows proper structure\n  let archive = @tar.TarArchive::empty()\n  \n  // Add entries of different sizes to test block alignment\n  let small_file = @tar.TarEntry::file(\"small.txt\", b\"Hi\")\n  let medium_file = @tar.TarEntry::file(\"medium.txt\", \"x\".repeat(600).to_bytes()) \n  let large_file = @tar.TarEntry::file(\"large.txt\", \"y\".repeat(1500).to_bytes())\n  \n  archive.add(small_file)\n  archive.add(medium_file)\n  archive.add(large_file)\n  \n  let tar_bytes = archive.to_bytes()\n  \n  // Verify TAR format requirements\n  @json.inspect(tar_bytes.length() % 512, content=0) // Must be 512-byte aligned\n  @json.inspect(tar_bytes.length() >= 10240, content=true) // Minimum size\n  \n  // Verify round-trip preserves all data\n  let parsed = @tar.TarArchive::of_bytes(tar_bytes)\n  @json.inspect(parsed.length(), content=3)\n  \n  // Check each file\n  guard parsed.find(\"small.txt\") is Some(f1) else {\n    fail(\"small.txt not found\")\n  }\n  assert_eq(f1.data, b\"Hi\")\n  \n  guard parsed.find(\"medium.txt\") is Some(f2) else {\n    fail(\"medium.txt not found\")\n  }\n  @json.inspect(f2.size, content=600)\n  \n  guard parsed.find(\"large.txt\") is Some(f3) else {\n    fail(\"large.txt not found\")\n  }\n  @json.inspect(f3.size, content=1500)\n}
