#!/usr/bin/env node
/**
 * tar_embed.js
 * Convert one or more .tar files into MoonBit source files embedding the raw bytes.
 * Intended for use via moon.pkg.json pre-build step.
 *
 * Usage:
 *   node scripts/tar_embed.js --input test1_simple.tar --name test1_simple_tar --output tar/embedded_test1_simple_test.mbt
 *   node scripts/tar_embed.js --dir tar --pattern "test*.tar" --outDir tar --suffix _auto_test.mbt
 *
 * Options:
 *   --input <file>        Single .tar file to embed
 *   --name <symbolName>   Variable name to use inside generated file (required with --input)
 *   --output <file>       Output .mbt file path (required with --input)
 *   --dir <directory>     Directory to scan for .tar files (pattern-based mode)
 *   --pattern <glob>      Glob pattern (minimally supports * wildcard) for selecting .tar files in scan mode
 *   --outDir <directory>  Output directory for scan mode (defaults to same as --dir)
 *   --suffix <suffix>     Suffix to append to base name for generated file (default: _embedded_test.mbt)
 *   --help                Show usage
 *
 * Two modes:
 * 1. Single-file mode (use --input, --name, --output)
 * 2. Batch mode (use --dir and optionally pattern/outDir/suffix). Symbol names become <basename>_tar.
 */

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

function usage(msg) {
  if (msg) console.error("Error:", msg);
  console.log(
    `Usage:\n  node scripts/tar_embed.js --input file.tar --name var_name --output out.mbt\n  node scripts/tar_embed.js --dir tar --pattern "test*.tar" --outDir tar --suffix _embedded_test.mbt`
  );
  process.exit(msg ? 1 : 0);
}

// Simple wildcard match supporting one * that can match any substring.
function simpleMatch(pattern, filename) {
  if (!pattern || pattern === "*") return true;
  const star = pattern.indexOf("*");
  if (star === -1) return pattern === filename;
  const pre = pattern.slice(0, star);
  const post = pattern.slice(star + 1);
  return filename.startsWith(pre) && filename.endsWith(post);
}

function bytesToHexLines(buf) {
  const parts = [];
  for (let i = 0; i < buf.length; i++) {
    const b = buf[i];
    const hex = "0x" + b.toString(16).padStart(2, "0");
    parts.push(hex);
  }
  // Format into lines of up to 12 bytes for readability
  const lines = [];
  for (let i = 0; i < parts.length; i += 12) {
    lines.push("  " + parts.slice(i, i + 12).join(", ") + ", ");
  }
  return lines.join("\n");
}

function generateMoonBit(symbolName, bytes) {
  return `// Generated by tar_embed.js, do not edit.\n///|\nlet ${symbolName} : Bytes = [\n${bytesToHexLines(
    bytes
  )}\n]\n`;
}

function writeFileEnsured(p, content) {
  fs.mkdirSync(path.dirname(p), { recursive: true });
  fs.writeFileSync(p, content, "utf8");
}

function formatMoonBit(filePath) {
  try {
    execSync(`moonfmt -w ${filePath}`, { stdio: "ignore" });
  } catch (e) {
    // Fallback: if moonfmt not available, ignore silently
    console.warn(
      `(warn) moonfmt failed or not installed; left unformatted: ${filePath}`
    );
  }
}

function singleMode(args) {
  const input = args["--input"];
  const name = args["--name"];
  const output = args["--output"];
  if (!input || !name || !output) usage("Missing --input, --name or --output");
  const bytes = fs.readFileSync(input);
  writeFileEnsured(output, generateMoonBit(name, bytes));
  formatMoonBit(output);
  console.log(
    `Embedded ${input} -> ${output} as ${name} (${bytes.length} bytes)`
  );
}

function batchMode(args) {
  const dir = args["--dir"];
  if (!dir) usage("Missing --dir for batch mode");
  const pattern = args["--pattern"] || "*.tar";
  const outDir = args["--outDir"] || dir;
  const suffix = args["--suffix"] || "_embedded_test.mbt";
  const entries = fs.readdirSync(dir);
  let count = 0;
  for (const f of entries) {
    if (!f.endsWith(".tar")) continue;
    if (!simpleMatch(pattern, f)) continue;
    const full = path.join(dir, f);
    const baseNoExt = f.replace(/\.tar$/, "");
    const symbol = baseNoExt + "_tar";
    const out = path.join(outDir, baseNoExt + suffix);
    const bytes = fs.readFileSync(full);
    writeFileEnsured(out, generateMoonBit(symbol, bytes));
    formatMoonBit(out);
    console.log(`Embedded ${f} -> ${out} as ${symbol} (${bytes.length} bytes)`);
    count++;
  }
  console.log(`Batch embedded ${count} file(s).`);
}

function parseArgs(argv) {
  const args = {};
  for (let i = 2; i < argv.length; i++) {
    const a = argv[i];
    if (a === "--help") {
      usage();
    }
    if (a.startsWith("--")) {
      const next = argv[i + 1];
      if (!next || next.startsWith("--")) {
        args[a] = true;
      } else {
        args[a] = next;
        i++;
      }
    } else {
      // positional unused
    }
  }
  return args;
}

(function main() {
  const args = parseArgs(process.argv);
  if (args["--input"]) return singleMode(args);
  if (args["--dir"]) return batchMode(args);
  usage("Specify either single-file options or batch directory.");
})();
